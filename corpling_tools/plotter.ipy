#!/usr/bin/python

#   Interrogating parsed corpora and plotting the results: plotter()
#   Author: Daniel McDonald

def plotter(title, results, fract_of = False, y_label = False, 
    num_to_plot = 7, skip63 = False, proj63 = 4, 
    multiplier = 100, projection = True, yearspan = False,
     justyears = False, csvmake = False, x_label = False, 
     legend_totals = False, log = False, figsize = 15, save = False):
    """
    Takes interrogator output and plots it with matplotlib

    title: String for chart title
    results: results in interrogator() output format.
        Results created with -C will not generate a legend.
    fract_of: a list of totals by which results will be divided. 
        The list should be in interrogator() -C output format. 
        By default, results will be multiplied by 100. 
        Absolute frequencies are given if false/omitted.
    num_to_plot: the top n results to be plotted (default 10)
    y_label: name for the y-axis (optional)
    multiplier: result * multiplier / total. 
        Use 100 for percentage, 1 for ratio.
    projection: project or do not project 1963 and 2014
    justyears = a list of years as integers to plot
    csvmake: enter filename as a string to make a csv file
    """

    # new options plan: smooth lines ...

    import matplotlib.pyplot as plt
    import pylab
    import numpy as np
    import os
    from time import localtime, strftime
    from IPython.display import display, clear_output
    from matplotlib.ticker import MaxNLocator
    from matplotlib.ticker import ScalarFormatter
    %matplotlib inline
    from pylab import rcParams
    from matplotlib import rc
    rcParams['figure.figsize'] = figsize, figsize/2
    import pylab as pl
    imagefolder = 'images'
    rcParams.update({'font.size': (figsize / 2) + 7}) # half your size plus seven
    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)

    def popper(interrogator_list):
        """removes totals"""

        return popped

    def skipper(interrogator_list):
        """Takes a list and returns a version without 1963"""
        skipped = []
        skipped.append(interrogator_list[0]) # append word
        for item in interrogator_list[1:]:
            if type(item) != unicode and type(item) != str and item[0] != 1963:
                skipped.append(item)
        return skipped

    def yearskipper(interrogator_list, justyears):
        """Takes a list and returns only results from the years listed in justyears"""
        
        skipped = []
        skipped.append(interrogator_list[0]) # append word
        for item in interrogator_list[1:]:
            if type(item) != unicode and type(item) != str:
                for year in justyears:
                    if item[0] == year:
                        skipped.append(item)
        return skipped

    def yearspanner(interrogator_list, yearspan):
        """Takes a list and returns results from between the first and last year in yearspan"""
        
        skipped = []
        skipped.append(interrogator_list[0]) # append word
        for item in interrogator_list[1:]:
            if type(item) != unicode and type(item) != str:
                if item[0] >= yearspan[0]:
                    if item [0] <= yearspan[-1]:
                        skipped.append(item)
        return skipped

    def projector(interrogator_list):
        """Takes a list and returns a version with projections"""
        projected = []
        projected.append(interrogator_list[0]) # append word
        for item in interrogator_list[1:]:
            if type(item) != str and type(item) != str and item[0] == 1963:
                newtotal = item[1] * proj63
                datum = [item[0], newtotal]
                projected.append(datum)
            elif type(item) != str and type(item) != str and item[0] == 2014:
                newtotal = item[1] * 1.37
                datum = [item[0], newtotal]
                projected.append(datum)
            else:
                projected.append(item)
        return projected

    def fraction_maker(first_list, second_list):
        """Takes two lists and returns fraction totals for plotting"""
        fractioned = []
        for entry in first_list:
            fractioned_entry = []
            fractioned_entry.append(entry[0]) # append word
            for part in entry[1:]:
                numerator = part[1]
                denominator_datum = second_list[entry.index(part)]
                if denominator_datum[1] == 0:
                    fraction = 0
                else:
                    fraction = numerator * multiplier / float(denominator_datum[1])
                datum = [part[0], fraction]
                fractioned_entry.append(datum)
            fractioned.append(fractioned_entry)
        return fractioned

    def csvmaker(csvdata, csvalldata, csvmake):
        """Takes whatever ended up getting plotted and puts it into a csv file"""
        csv = []
        yearlist = []
        # get list of years
        for entry in csvdata[0]:
            if type(entry) == list:
                yearlist.append(str(entry[0]))
        # make first line
        csv.append(title)
        # make the second line
        years = ',' + ','.join(yearlist)
        csv.append(years)
        # for each word
        for entry in csvdata:
            csvline = []
            csvcounts = []
            csvline.append(entry[0]) # append word
            for part in entry[1:]:
                csvcounts.append(str(part[1])) # append just the count
            counts = ','.join(csvcounts)
            csvline.append(counts)
            line = ','.join(csvline)
            csv.append(line)
        csv = '\n'.join(csv)
        # now do all data
        csvall = []
        yearlist = []
        # get list of years
        for entry in csvalldata[0]:
            if type(entry) == list:
                yearlist.append(str(entry[0]))
        # make first line
        csvall.append(title)
        # make the second line
        years = ',' + ','.join(yearlist)
        csvall.append(years)
        # for each word
        for entry in csvalldata:
            csvallline = []
            csvallcounts = []
            csvallline.append(entry[0]) # append word
            for part in entry[1:]:
                csvallcounts.append(str(part[1])) # append just the count
            counts = ','.join(csvallcounts)
            csvallline.append(counts)
            line = ','.join(csvallline)
            csvall.append(line)
        csvall = '\n'.join(csvall)
        # write the csvall file?
        if os.path.isfile(csvmake):
            raise ValueError("CSV error: %s already exists in current directory. Move it, delete it, or change the name of the new .csv file." % csvmake)
        try:
            fo=open(csvmake,"w")
        except IOError:
            print "Error writing CSV file."
        fo.write('Plotted results:\n'.encode("UTF-8"))
        fo.write(csv.encode("UTF-8"))
        fo.write('\n\nAll results:\n'.encode("UTF-8"))
        fo.write(csvall.encode("UTF-8"))
        fo.close()
        time = strftime("%H:%M:%S", localtime())
        print time + ": " + csvmake + " written to currect directory."

    ##################################################################

    # copy results and embed in list if need be.
    if csvmake:
        cutoff = len(results)
    else:
        cutoff = num_to_plot
    if type(results[0]) == unicode or type(results[0]) == str:
        legend = False
        data = [list(results)][:cutoff]
        alldata = [list(results)][:cutoff]
    else:
        legend = True
        data = list(results[:cutoff])
        alldata = list(results[:cutoff])
    # cut it short if we're not saving results
    if not csvmake:
        alldata = alldata[:num_to_plot]

    # find out if we're doing years or not:
    if x_label:
        x_lab = x_label
    else:
        check_x_axis = data[0] # get first entry
        check_x_axis = check_x_axis[1] # get second entry of first entry (year, count)
        if 1500 < check_x_axis[0] < 2050:
            x_lab = 'Year'
        else:
            x_lab = 'Group'
    # copy totals data so as to not edit it
    if fract_of:
        totals = list(fract_of)
        # make fractions
        fractdata = fraction_maker(data, totals)
        data = list(fractdata)
        alldata = list(fractdata)

    csvdata = []
    csvalldata = []
    final = []
    colours = ["#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f", "#cab2d6"]
    c = 0
    for index, entry in enumerate(alldata):
        # run called processes
        if skip63:
            entry = skipper(entry)
        if yearspan:
            entry = yearspanner(entry, yearspan)
        if justyears:
            entry = yearskipper(entry, justyears)
        if projection:
            if not fract_of:
                entry = projector(entry)
        # get word
        word = entry[0]
        # what the hell is this?
        # get proper total here!
        if entry[-1][0] == 'Total':
            total = str(float(entry[-1][1]))
        else:
            total = 0
        #print str(total)
        if fract_of:
            totalstring = ' (%s%%)' % total
        else:
            totalstring = ' (n=%s)' % total
        entry.pop() # get rid of total. good or bad?
        csvalldata.append(entry) 
        # it takes a bit too long to process huge lists, 
        # when they aren't being used! Quick fix is to slice the
        # results passed to plotter, but eh.
        # for each datum [year, count]:
        if index < num_to_plot:
            csvdata.append(entry)
            toplot = []
            xvalsbelow = []
            yvalsbelow = []
            xvalsabove = []
            yvalsabove = []
            d = 1 # first tuple, maybe not very stable
            tups = len(entry) - 2 # all tuples minus 2 (to skip totals tuple)
            for _ in range(tups):
                firstpart = entry[d] # first tuple
                firstyear = firstpart[0]
                nextpart = entry[d + 1]
                nextyear = nextpart[0]
                diff = nextyear - firstyear
                if nextyear - firstyear > 1:
                    xvalsbelow.append(firstpart[0])
                    yvalsbelow.append(firstpart[1])
                    xvalsbelow.append(nextpart[0])
                    yvalsbelow.append(nextpart[1])
                else:
                    xvalsabove.append(firstpart[0])
                    yvalsabove.append(firstpart[1])
                    xvalsabove.append(nextpart[0])
                    yvalsabove.append(nextpart[1])
                d += 1
            # do actual plotting
            plt.plot(xvalsbelow, yvalsbelow, '--', color=colours[c])
            plt.plot(xvalsabove, yvalsabove, '.', color=colours[c]) # delete for nyt
            if legend_totals:
                plt.plot(xvalsabove, yvalsabove, '-', label=word + totalstring, color=colours[c])
                plt.plot(xvalsabove, yvalsabove, '.', color=colours[c]) # delete for nyt
            else:
                plt.plot(xvalsabove, yvalsabove, '-', label=word, color=colours[c])
                plt.plot(xvalsabove, yvalsabove, '.', color=colours[c]) # delete for nyt
            if c == 8:
                c = 0 # unpythonic
            c += 1
        
        # old way to plot everything at once
        #plt.plot(*zip(*toplot), label=word) # this is other projects...
    
    #make legend
    if legend:
        lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)

    # make axis labels
    plt.xlabel(x_lab)
    if not y_label:
        #print "Warning: no name given for y-axis. Using default."
        if fract_of:
            y_label = 'Percentage'
        if not fract_of:
            y_label = 'Total frequency'
    # no decimals on x axis:
    # make the chart
    plt.gca().get_xaxis().set_major_locator(MaxNLocator(integer=True))
    plt.ylabel(y_label)
    pylab.title(title)
    if log == 'x':
        plt.xscale('log')
        plt.gca().get_xaxis().set_major_formatter(ScalarFormatter())
    elif log == 'y':
        plt.yscale('log')
        plt.gca().get_yaxis().set_major_formatter(ScalarFormatter())
    elif log == 'x, y':
        plt.xscale('log')
        plt.gca().get_xaxis().set_major_formatter(ScalarFormatter())
        plt.yscale('log')
        plt.gca().get_yaxis().set_major_formatter(ScalarFormatter())
    else:
        plt.ticklabel_format(useOffset=False, axis='x', style = 'plain')
    plt.grid()
    fig1 = plt.gcf()
    plt.show()
    if save:
        def urlify(s):
            import re
            s = s.lower()
            s = re.sub(r"[^\w\s]", '', s)
            s = re.sub(r"\s+", '-', s)
            return s     
        if type(save) == str:
            savename = os.path.join(imagefolder, urlify(save) + '.png')
        else:
            savename = os.path.join(imagefolder, urlify(title) + '.png')
        if legend:
            fig1.savefig(savename, bbox_extra_artists=(lgd,), bbox_inches='tight', dpi=150) 
        time = strftime("%H:%M:%S", localtime())
        print time + ": " + savename + " created."
    if csvmake:
        csvmaker(csvdata, csvalldata, csvmake)
        